/*
 * This file is part of Nebulae.
 * Copyright (C) 2011 - Leo Testard <leo.testard@gmail.com>
 *
 * Nebulae is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Nebulae is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Nebulae. If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef NEBULAEMIMETYPEINFO_H
#define NEBULAEMIMETYPEINFO_H

#include <QtCore/QString>

#include "nebulae-application.h"
#include "nebulae-basedir.h"

class QIcon;
class DesktopEntry;

/**
  * \struct MimeType
  * \brief Describes a MIME type
  * A MIME Type represents the TYPE of a file, and can be associated to the "file extensions" of Microsoft Windows, but in fact, it goes further.
  * A MIME Type can refer wether to a file, wether to a directory or a special block (devices, pipes...). It gives informations about the extensions currently used for this file type but does not depend
  * on it and can as well determine the type of a file with its "magic number". It also provides a short, localized, description, an icon to represent files of this type in a view, and a complex system of
  * aliases and subclasses to make things more expandable.s
  */
class MimeType
{
public:
    /**
     * \brief Builds a MIME type and initialize all the given informations.
     * \param name The name of the MIME type, like text/html. It's often used to get other informations.
     * \param icon The name of an icon, that can thus be loaded from theme.
     * \param subclass The name of type that this type "inherits" of. E.G. text/html sould have text/plain
     * \param ext A list of all file extensions that this file can have, e.g. ("*.html","*.xhtml","*.htm")
     * \param alias_target If this type is an alias for another type, mention the target type here. Is this parameter is ommitted, the type is not considered as an alias.
     */
    MimeType(const QString &name, const QString &icon, const QString &subclass, QStringList ext, const QString &alias_target = 0) : m_name(name), m_subclass(subclass), m_alias_target(alias_target), m_icon(icon), m_ext(ext)
    {
        if(alias_target.isEmpty())
            m_alias = false;
        else
            m_alias = true;
    }

    /**
      * \brief Returns the name of the type.
      */
    QString name();

    /**
      * \brief Returns the name of the icon that represents this type.
      * \warning Distinction between paths and icon names is not implemented yet. It can be wether an absolute path to an icon file wether the name of a theme-loadable icon.
      * \note If this type is an alias, the icon is the one of the target type. If finally no icon is found, it tries to get the one of the subclass of the type.
      */
    QString icon();

    /**
      * \brief Returns the list of every extensions used by this file type.
      * \note The extensions are of the shape "*.xml"
      */
    QStringList extensions();

    /**
      * \brief Returns true is tis type is an alias, otherwise returns false
      */
    bool isAlias();

    /**
      * \brief If this type is an alias, returns the name of the target type. Otherwie returns an empty string
      */
    QString aliasTarget();

    /**
      * \brief If exists, returns the name of the subclass of this type
      */
    QString subclass();

private:
    QString m_name, m_subclass, m_alias_target, m_icon;
    QStringList m_ext;
    bool m_alias;
};

/**
  * \brief Provides a quick access to MIME Type informations
  * Informations about MIME types are splitted into several files and directories, which are themselves generated by the update-mime-database program, by reading one xml by type.
  * This class read all that files and centralize all informations that it can get in a list of MimeType instances. You can then use it to get a MIME type by its name.
  */
class MimeTypeDatabase
{

public:
    /**
      * \brief Initialize the database. Once initialized, the files have already been read and cached into memory.
      * \warning If you're using NebulaeApplication in you program, there is already an instance of this class accessible via nApp->mimeTypeDatabase(). You should use it
      * instead of creating another one.
      */
    MimeTypeDatabase();

    /**
      * \brief Finds a MIME type by its name in the database.
      * \return a pointer to a MimeType instance from which you can get all informations about this type.
      */
    MimeType findType(const QString &name);

    /**
      * \brief Returns the type of the given file
      * \return a pointer to a MimeType instance from which you can get all informations about this type.
      */
    MimeType fileType(QFileInfo file);

    /**
      * \brief Returns the program used by default to open this type of files
      * \return an instance ok the DesktopEntry class.
      * \warning User-specific settings override system-wide configuration
      * \note returns the same thing than programsForType().first();
      */
    DesktopEntry programForType(MimeType type);

    /**
      * \brief Returns a list of the programs that can be used to open this type.
      * \note This list is sorted : the preferred programs firts. User-specific settings override system-wide configuration
      */
    QList<DesktopEntry> programsForType(MimeType type);

    /**
      * \brief Returns an human-readable description of the type.
      * \example For image/png -> Portable Network Graphics File
      */
    QString description(MimeType type, QString locale);

private:
    // cache copy of the database
    QList<MimeType> m_cache;
    // read the files again and rebuild the cache
    QList<MimeType> m_update_cache();
};

#endif // NEBULAEMIMETYPEINFO_H
